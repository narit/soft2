/**
 *  学籍番号: 03-123006
 *  氏名: 岩成達哉
 *      課題3: 入力が3次元の関数を考え，極小値を計算
 *          極小値を計算させた入力が3次元の関数として
 *          f(x, y, z) = cos(x) + sin(y) + cos(z)
 *          を選ぶ。
 *
 *          これに対し，初期点(0, 0, 0)，変化の割合αを0.01，終了条件を|∇f| < 0.0001とすると，
 *          最急降下法によって，
 *          987回目に
 *          x =  0.0000, y = -1.5707, z =  0.0000, f =  1.0000
 *          が得られる。
 *
 *          これが求まった極小値である。
 *          一つの極小値しか求まっていないが，fは周期性から，明らかに複数の極小値が存在する。
 *          この極小値は，初期点と変化の割合の与え方によって変化する。
 *
 *          例えば，初期点は変えず，変化の割合を2とすると終了条件を満たす値の前後を行き来して収束しなくなる。
 *          しかし，変化の割合を1とすると
 *          4回目で
 *          x =  0.0000, y = -1.5708, z =  0.0000, f =  1.0000
 *          とすぐに収束する。
 *          つまり，適切な刻み幅にすることで計算回数を少なくできるが，
 *          大きくし過ぎると収束しなくなるという問題があることがわかる。
 *
 *          また逆に，変化の割合を変えず，初期点を(1, 1, 1)とすると，変化の割合が0.01のときは
 *          1133回目に
 *          x =  3.1416, y = -1.5707, z =  3.1416, f = -3.0000
 *          に収束する。
 *          三角関数の性質からこれが最小値であることは明らかである。
 *          基本的には，変化の割合が十分小さければ初期点に近い極小値へと収束するが，
 *          変化の割合が大きければ飛び越して別の極小値を指したり，極大値を指したりする。
 *
 *          また，もちろん極小値がない問題も収束しない[ex)x + (y - 1)^3 + z - 1]。
 */
#include <math.h>
#include "func.h"

/* 次元を返す */
int f_dimension()
{
    return 3;
}

/* 関数値を返す */
double f_value(const double x[])
{
    // cos(x) + sin(y) + cos(z)
    return cos(x[0]) + sin(x[1]) + cos(x[2]);
}

/* 勾配を計算する */
void f_gradient(const double x[], double g[])
{
    g[0] = -sin(x[0]);  // ∂f/∂x = -sin(x)
    g[1] =  cos(x[1]);  // ∂f/∂y =  cos(y)
    g[2] = -sin(x[2]);  // ∂f/∂z = -sin(z)
}