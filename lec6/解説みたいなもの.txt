問題1
	count_symbols() を修正し、シンボルの出現回数を数えるよう修正せよ

count_symbols() を見てみると，
  int i;
  for (i = 0; i < NSYMBOLS; i++) {
    count[i] = rand() % 100;
  }
というようにそれぞれの文字の出現数がランダムにcountという配列に入っています。
countという配列には，それぞれの文字(シンボル)の出現回数を入れておきます。

対応としては，count['a']にaの出現回数，count['b']にbの出現回数…というように入れておきます。
(※ここで'a'というのは文字コードにしたがって数値に変換されるので，'a'なら97を表します)

今回はバイナリファイルを読みだすので(fopenの指定が"rb"となっている)，freadを使います。
(freadの使い方については http://www9.plala.or.jp/sgwr-t/lib/fread.html )

例えばabc...となっていたら，それを一文字ずつ変換すればいいので，
バイナリファイルから1バイト(0~255)ずつ読んでいって，
それに対応する添字のcountをインクリメントすればいいです。

1バイトはchar型の変数を用意してそいつに読み取りましょう。
それを添え字にそのまま使えばいいです。

freadはEOF(ファイルの終わり)まで来たら0を返すのでそこまで1バイトずつwhileで回しましょう。

確かめは，適当なテキストファイルを対象にしてwhileの後に
  int i;
  for (i = 0; i < NSYMBOLS; i++)
    printf("Num of %c : %d\n", i, count[i]);
でやってみてください。

-----
課題2
	build_tree() 関数を完成させよ

コードをちょっと読まないとわからないと思います。

まずはハフマン符号の復習からですね。
http://www.snap-tck.com/room03/c02/comp/comp032.html
の図がハフマン符号の作り方を示していてわかりやすいと思います。

上のリンクで復習を終えたら，build_treeの中にある
  while (n >= 2) {
    Node *node1 = pop_min(&n, nodes);
    Node *node2 = pop_min(&n, nodes);

    // create a new node
    
  }
の部分を見てみます。

何やらnode1とnode1というものを取り出していますね。

pop_min関数を眺めてみます。
Node* pop_min(int *n, Node *nodes[])
{
  // find a node with the smallest count
  int i, j = 0;
  for (i = 0; i < *n; i++) {
    if (nodes[i]->count < nodes[j]->count) {	// 要素iのほうが要素jより出現数が少ない
      j = i;	// もっとも出現数が少ない要素(の添字)を更新
    }
  }

  Node *node_min = nodes[j];	// もっとも出現数が少ない要素

  // a b c d e とならんでいてcが最小だったなら a b d e となるように詰める
  // remove the node from nodes[]
  for (i = j; i < (*n) - 1; i++) {
    nodes[i] = nodes[i + 1];	// 詰めていく
  }
  (*n)--;	// 一つ減らしたので要素数を減らしておく

  return node_min;	// もっとも出現数が少ない要素を返す
}
となっていますね。

したがって，build_treeのwhileの中では，
どうやら出現回数が最小の要素を2個(node1, node2)を抽出しているようです。

これは先程のリンクで最も確率の小さいものを2つ抽出しているのと同じです。
そして，create a new nodeというのは先程のリンクで要素2つを子に持つノードを作ってる部分に相当します。
つまり，要素をmallocで新たにつくって，その要素の右の子と左の子をnode1とnode2にし，
countをnode1とnode2のcountの合計にします。

これでノードを作ったことにはなりますが，リンクのように今度はその要素を含めて，
確率が最も低いものを取り出す必要があります。
したがって，新しく作った要素をnodesに追加しましょう。
今，nodesの要素数は，nによって管理されています。
したがって，nodes[n]に新しく作った要素をいれるといいですね。

このようにしておけばwhileで勝手に木をつくってくれます。

-----
課題3
	traverse_tree() 関数を修正し、各シンボルに対するコード語を求めよ
	
ハフマン符号では，符号の木の深さがそのまま符号長になることは明らかだと思います。

シンボルは常に葉にあり，シンボル以外のノードは必ず2つの子を持つように課題2でなっています。
したがって，traverse_treeで
  if (np->left == NULL) {
    return;
  }
と判定しているのは，「左の子が無いものは葉っぱである」ということがわかるからです。

この中で符号語を出力するコードを書きます。

では，出力する符号語の作り方ですが，リンクのように，
ハフマン符号は左の子に行く時に0，右の子に行く時に1と決めると，
それだけで符号ができます。

traverse_treeは再帰処理によって，根からどんどん葉っぱのほうに向かっていきます。
なので，左に行くときは0，右に行くときは1というように再帰の直前に処理を書いておけばいいですね。

簡単な方法はint code[NSYMBOLS]というような配列を用意して，
再帰のたびにcodeに0か1かを入れておく方法ですね。

あとは，「その要素がある葉までの符号の木の深さ=符号長」ということを利用して
for文で回すと良いです。

確認はテキストファイルをつかって結果を表示して，
もっとも多く出ている文字にもっとも少ない長さの符号語があてられているか見ることです。
(自分で符号の木を書いて確かめるのもあり)